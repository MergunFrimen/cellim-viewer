This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  api/
    contracts/
      requests/
        entries.py
        views.py
      responses/
        common.py
        entries.py
        views.py
      base.py
    endpoints/
      entries.py
      views.py
  database/
    models/
      __init__.py
      base.py
      entry.py
      link.py
      user.py
      view.py
    docker-compose.yml
    session.py
  shared/
    config.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/contracts/requests/entries.py">
from typing import Optional

from pydantic import Field

from app.api.contracts.base import EntryBase


class EntryCreateRequest(EntryBase):
    pass


class EntryUpdateRequest(EntryBase):
    name: Optional[str] = Field(None, min_length=1, max_length=50)
    description: Optional[str] = None
    is_public: Optional[bool] = None
</file>

<file path="app/api/contracts/requests/views.py">
from typing import Any, Dict, Optional
from uuid import UUID

from pydantic import BaseModel, Field

from app.api.contracts.base import ViewBase


class ViewCreateRequest(ViewBase):
    entry_id: UUID


class ViewUpdateRequest(ViewBase):
    pass
</file>

<file path="app/api/contracts/responses/common.py">
from typing import List

from pydantic import BaseModel


class PaginatedResponse[T](BaseModel):
    items: List[T]
    total: int
    page: int
    per_page: int
    total_pages: int
</file>

<file path="app/api/contracts/responses/entries.py">
from datetime import datetime
from typing import Optional
from uuid import UUID

from app.api.contracts.base import EntryBase


class EntryResponse(EntryBase):
    id: UUID
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True
</file>

<file path="app/api/contracts/responses/views.py">
from datetime import datetime
from typing import Optional
from uuid import UUID

from app.api.contracts.base import ViewBase


class ViewResponse(ViewBase):
    id: UUID
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True
</file>

<file path="app/api/contracts/base.py">
from typing import Any, Dict, Optional

from pydantic import BaseModel, Field


class EntryBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    description: Optional[str] = None
    is_public: bool = True


class ViewBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=50)
    description: str
    mvsj: Optional[Dict[str, Any]] = None
</file>

<file path="app/api/endpoints/entries.py">
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from app.api.contracts.requests.entries import EntryCreateRequest, EntryUpdateRequest
from app.api.contracts.responses.common import PaginatedResponse
from app.api.contracts.responses.entries import EntryResponse
from app.database.models.entry import Entry
from app.database.session import get_db

router = APIRouter()


@router.post("", response_model=EntryResponse, status_code=201)
def create_entry(entry: EntryCreateRequest, db: Session = Depends(get_db)):
    new_entry = Entry(
        id=uuid4(),
        name=entry.name,
        description=entry.description,
        is_public=entry.is_public,
        created_at=datetime.now(),
        updated_at=datetime.now(),
        deleted_at=None,
        views=[],
    )

    db.add(new_entry)
    db.commit()
    db.refresh(new_entry)

    return new_entry


@router.get("", response_model=PaginatedResponse[EntryResponse])
def list_entries(
    search: Optional[str] = None,
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
):
    query = db.query(Entry).filter(Entry.deleted_at.is_(None), Entry.is_public.is_(True))

    if search:
        search_term = f"%{search}%"
        query = query.filter(
            (Entry.name.ilike(search_term)) | (Entry.description.ilike(search_term))
        )

    total = query.count()
    query = query.order_by(Entry.created_at.desc())
    query = query.offset((page - 1) * per_page).limit(per_page)
    entries = query.all()
    total_pages = (total + per_page - 1) // per_page  # Ceiling division

    return {
        "items": entries,
        "total": total,
        "page": page,
        "per_page": per_page,
        "total_pages": total_pages,
    }


@router.get("/{entry_id}", response_model=EntryResponse)
def get_entry(entry_id: UUID, db: Session = Depends(get_db)):
    entry = db.query(Entry).filter(Entry.id == entry_id, Entry.deleted_at.is_(None)).first()

    if not entry:
        raise HTTPException(status_code=404, detail="Entry not found")

    return entry


@router.put("/{entry_id}", response_model=EntryResponse)
def update_entry(entry_id: UUID, entry_data: EntryUpdateRequest, db: Session = Depends(get_db)):
    entry = db.query(Entry).filter(Entry.id == entry_id, Entry.deleted_at.is_(None)).first()

    if not entry:
        raise HTTPException(status_code=404, detail="Entry not found")

    # Update fields if they are provided
    if entry_data.name is not None:
        entry.name = entry_data.name
    if entry_data.description is not None:
        entry.description = entry_data.description
    if entry_data.is_public is not None:
        entry.is_public = entry_data.is_public

    entry.updated_at = datetime.now()

    db.commit()
    db.refresh(entry)

    return entry


@router.delete("/{entry_id}", status_code=204)
def delete_entry(entry_id: UUID, db: Session = Depends(get_db)):
    entry = db.query(Entry).filter(Entry.id == entry_id, Entry.deleted_at.is_(None)).first()

    if not entry:
        raise HTTPException(status_code=404, detail="Entry not found")

    # Soft delete
    entry.deleted_at = datetime.now()

    db.commit()

    return None
</file>

<file path="app/api/endpoints/views.py">
from datetime import datetime
from uuid import UUID, uuid4

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.api.contracts.requests.views import ViewCreateRequest, ViewUpdateRequest
from app.api.contracts.responses.views import ViewResponse
from app.database.models.entry import Entry
from app.database.models.view import View
from app.database.session import get_db

router = APIRouter()


@router.post("", response_model=ViewResponse, status_code=201)
def create_view(view: ViewCreateRequest, db: Session = Depends(get_db)):
    # Check if entry exists
    entry = db.query(Entry).filter(Entry.id == view.entry_id, Entry.deleted_at.is_(None)).first()
    if not entry:
        raise HTTPException(status_code=404, detail="Entry not found")

    # Create new view
    new_view = View(
        id=uuid4(),
        name=view.name,
        description=view.description,
        mvsj=view.mvsj,
        entry_id=view.entry_id,
        created_at=datetime.now(),
        updated_at=datetime.now(),
        deleted_at=None,
        entry=entry,
    )

    db.add(new_view)
    db.commit()
    db.refresh(new_view)

    return new_view


@router.get("/entry/{entry_id}", response_model=list[ViewResponse])
def get_views_for_entry(entry_id: UUID, db: Session = Depends(get_db)):
    # Check if entry exists
    entry = db.query(Entry).filter(Entry.id == entry_id, Entry.deleted_at.is_(None)).first()
    if not entry:
        raise HTTPException(status_code=404, detail="Entry not found")

    # Get views
    views = db.query(View).filter(View.entry_id == entry_id, View.deleted_at.is_(None)).all()

    return views


@router.get("/{view_id}", response_model=ViewResponse)
def get_view(view_id: UUID, db: Session = Depends(get_db)):
    view = db.query(View).filter(View.id == view_id, View.deleted_at.is_(None)).first()

    if not view:
        raise HTTPException(status_code=404, detail="View not found")

    return view


@router.put("/{view_id}", response_model=ViewResponse)
def update_view(view_id: UUID, view_data: ViewUpdateRequest, db: Session = Depends(get_db)):
    view = db.query(View).filter(View.id == view_id, View.deleted_at.is_(None)).first()

    if not view:
        raise HTTPException(status_code=404, detail="View not found")

    # Update fields if they are provided
    if view_data.name is not None:
        view.name = view_data.name
    if view_data.description is not None:
        view.description = view_data.description
    if view_data.mvsj is not None:
        view.mvsj = view_data.mvsj

    view.updated_at = datetime.now()

    db.commit()
    db.refresh(view)

    return view


@router.delete("/{view_id}", status_code=204)
def delete_view(view_id: UUID, db: Session = Depends(get_db)):
    view = db.query(View).filter(View.id == view_id, View.deleted_at.is_(None)).first()

    if not view:
        raise HTTPException(status_code=404, detail="View not found")

    # Soft delete
    view.deleted_at = datetime.now()

    db.commit()

    return None
</file>

<file path="app/database/models/__init__.py">
from .base import Base
from .entry import Entry
from .link import Link
from .user import User
from .view import View
</file>

<file path="app/database/models/base.py">
from typing import Any
from uuid import UUID

from sqlalchemy import JSON, String
from sqlalchemy.orm import DeclarativeBase, MappedAsDataclass, mapped_column
from typing_extensions import Annotated

# https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html#step-five-make-use-of-pep-593-annotated-to-package-common-directives-into-types
str255 = Annotated[str, 255]
uuidpk = Annotated[UUID, mapped_column(primary_key=True)]


class Base(DeclarativeBase, MappedAsDataclass):
    type_annotation_map = {
        dict[str, Any]: JSON,
        str255: String(50),
    }
</file>

<file path="app/database/models/entry.py">
from datetime import datetime

from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.database.models.base import Base, str255, uuidpk


class Entry(Base):
    __tablename__ = "entries"

    # Attributes
    id: Mapped[uuidpk]
    name: Mapped[str255]
    description: Mapped[str | None]
    is_public: Mapped[bool]
    created_at: Mapped[datetime | None]
    updated_at: Mapped[datetime | None]
    deleted_at: Mapped[datetime | None]

    # Relationships
    views: Mapped[list["View"]] = relationship(back_populates="entry")
    links: Mapped["Link"] = relationship(back_populates="entry")
    user_id: Mapped[uuidpk] = mapped_column(ForeignKey("users.id"))
    user: Mapped["User"] = relationship(back_populates="entries")
</file>

<file path="app/database/models/link.py">
from datetime import datetime
from enum import Enum

from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.database.models.base import Base, uuidpk


class LinkType(Enum):
    viewer = "viewer"
    editor = "editor"


class Link(Base):
    __tablename__ = "links"

    # Attributes
    id: Mapped[uuidpk]
    type: Mapped[LinkType]
    created_at: Mapped[datetime | None]
    updated_at: Mapped[datetime | None]
    deleted_at: Mapped[datetime | None]

    # Relationships
    entry_id: Mapped[uuidpk] = mapped_column(ForeignKey("entries.id"), unique=True)
    entry: Mapped["Entry"] = relationship()
    user_id: Mapped[uuidpk] = mapped_column(ForeignKey("users.id"), unique=True)
    user: Mapped["User"] = relationship()
</file>

<file path="app/database/models/user.py">
from datetime import datetime

from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.database.models.base import Base, uuidpk


class User(Base):
    __tablename__ = "users"

    # Attributes
    id: Mapped[uuidpk]
    created_at: Mapped[datetime | None]
    updated_at: Mapped[datetime | None]
    deleted_at: Mapped[datetime | None]

    # Relationships
    entries: Mapped[list["Entry"]] = relationship()
</file>

<file path="app/database/models/view.py">
from datetime import datetime
from typing import Any

from sqlalchemy import ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.database.models.base import Base, str255, uuidpk


class View(Base):
    __tablename__ = "views"

    # Attributes
    id: Mapped[uuidpk]
    name: Mapped[str255]
    description: Mapped[str]
    mvsj: Mapped[dict[str, Any] | None]
    created_at: Mapped[datetime | None]
    updated_at: Mapped[datetime | None]
    deleted_at: Mapped[datetime | None]

    # Relationships
    entry_id: Mapped[uuidpk] = mapped_column(ForeignKey("entries.id"), unique=True)
    entry: Mapped["Entry"] = relationship()
</file>

<file path="app/database/docker-compose.yml">
services:
  db:
    container_name: cellim-viewer-db
    image: postgres:17.4-alpine
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=cellim_viewer
    # volumes:
    #   - postgres_data:/var/lib/postgresql/data/

# volumes:
#  postgres_data:
</file>

<file path="app/database/session.py">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from app.shared.config import settings

engine = create_engine(settings.DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="app/shared/config.py">
import os
from typing import List

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    APP_NAME: str = "CELLIM Viewer"

    # CORS
    CORS_ORIGINS: List[str] = [
        "http://localhost:3000",  # React frontend
        "http://localhost:8000",  # FastAPI backend (for OpenAPI docs)
    ]

    # PostgreSQL
    POSTGRES_DIALECT: str = "postgresql"
    POSTGRES_DBAPI: str = "psycopg"
    POSTGRES_USER: str = os.getenv("POSTGRES_USER", "postgres")
    POSTGRES_PASSWORD: str = os.getenv("POSTGRES_PASSWORD", "postgres")
    POSTGRES_SERVER: str = os.getenv("POSTGRES_SERVER", "localhost")
    POSTGRES_DB: str = os.getenv("POSTGRES_DB", "cellim_viewer")
    DATABASE_URL: str = f"{POSTGRES_DIALECT}+{POSTGRES_DBAPI}://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_SERVER}/{POSTGRES_DB}"

    class Config:
        env_file = ".env"
        case_sensitive = True


settings = Settings()
</file>

</files>
